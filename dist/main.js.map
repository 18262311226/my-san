{"version":3,"file":"main.js","mappings":"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","sources":["webpack://my-san/./src/parser/read-ident.js","webpack://my-san/./src/parser/read-unary-expr.js","webpack://my-san/./src/parser/expr-type.js","webpack://my-san/./src/parser/read-string.js","webpack://my-san/./src/parser/read-parenthesized-expr.js","webpack://my-san/./src/parser/read-call.js","webpack://my-san/./src/parser/read-accessor.js","webpack://my-san/./src/parser/read-multiplicative-expr.js","webpack://my-san/./src/parser/read-additive-expr.js","webpack://my-san/./src/parser/read-relational-expr.js","webpack://my-san/./src/parser/read-logical-and-expr.js","webpack://my-san/./src/parser/read-equality-expr.js","webpack://my-san/./src/parser/read-logical-or-expr.js","webpack://my-san/./src/parser/read-tertiary-expr.js","webpack://my-san/./src/parser/walker.js","webpack://my-san/./src/parser/parse-Expr.js","webpack://my-san/./src/runtime/data.js","webpack://my-san/./src/main.js"],"sourcesContent":["/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取ident\r\n */\r\n\r\n/**\r\n * 读取ident\r\n * 这里的 ident 指标识符(identifier)，也就是通常意义上的变量名\r\n * 这里默认的变量名规则为：由美元符号($)、数字、字母或者下划线(_)构成的字符串\r\n *\r\n * @inner\r\n * @param {Walker} walker 源码读取对象\r\n * @return {string}\r\n */\r\nexport function readIdent(walker) {\r\n    var match = walker.match(/\\s*([\\$0-9a-z_]+)/ig, 1);\r\n\r\n    // #[begin] error\r\n    if (!match) {\r\n        throw new Error('[SAN FATAL] expect an ident: ' + walker.source.slice(walker.index));\r\n    }\r\n    // #[end]\r\n\r\n    return match[1];\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取一元表达式\r\n */\r\nimport { ExprType } from './expr-type.js';\r\nimport {readString } from './read-string.js';\r\nimport { readCall } from './read-call.js';\r\nimport { readParenthesizedExpr } from './read-parenthesized-expr.js';\r\nimport { readTertiaryExpr } from './read-tertiary-expr.js';\r\n\r\nfunction postUnaryExpr(expr, operator) {\r\n    switch (operator) {\r\n        case 33:\r\n            var value;\r\n            switch (expr.type) {\r\n                case ExprType.NUMBER:\r\n                case ExprType.STRING:\r\n                case ExprType.BOOL:\r\n                    value = !expr.value;\r\n                    break;\r\n                case ExprType.ARRAY:\r\n                case ExprType.OBJECT:\r\n                    value = false;\r\n                    break;\r\n                case ExprType.NULL:\r\n                    value = true;\r\n                    break;\r\n            }\r\n\r\n            if (value != null) {\r\n                return {\r\n                    type: ExprType.BOOL,\r\n                    value: value\r\n                };\r\n            }\r\n            break;\r\n\r\n        case 43:\r\n            switch (expr.type) {\r\n                case ExprType.NUMBER:\r\n                case ExprType.STRING:\r\n                case ExprType.BOOL:\r\n                    return {\r\n                        type: ExprType.NUMBER,\r\n                        value: +expr.value\r\n                    };\r\n            }\r\n            break;\r\n\r\n        case 45:\r\n            switch (expr.type) {\r\n                case ExprType.NUMBER:\r\n                case ExprType.STRING:\r\n                case ExprType.BOOL:\r\n                    return {\r\n                        type: ExprType.NUMBER,\r\n                        value: -expr.value\r\n                    };\r\n            }\r\n            break;\r\n    }\r\n\r\n    return {\r\n        type: ExprType.UNARY,\r\n        expr: expr,\r\n        operator: operator\r\n    };\r\n}\r\n\r\n/**\r\n * 读取一元表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readUnaryExpr(walker) {\r\n    walker.goUntil();\r\n\r\n    var currentCode = walker.source.charCodeAt(walker.index);\r\n    switch (currentCode) {\r\n        case 33: // !\r\n        case 43: // +\r\n        case 45: // -\r\n            walker.index++;\r\n            return postUnaryExpr(readUnaryExpr(walker), currentCode);\r\n\r\n        case 34: // \"\r\n        case 39: // '\r\n            return readString(walker);\r\n\r\n        case 48: // number\r\n        case 49:\r\n        case 50:\r\n        case 51:\r\n        case 52:\r\n        case 53:\r\n        case 54:\r\n        case 55:\r\n        case 56:\r\n        case 57:\r\n            return {\r\n                type: ExprType.NUMBER,\r\n                value: +(walker.match(/[0-9]+(\\.[0-9]+)?/g, 1)[0])\r\n            };\r\n\r\n        case 40: // (\r\n            return readParenthesizedExpr(walker);\r\n\r\n        // array literal\r\n        case 91: // [\r\n            walker.index++;\r\n            var arrItems = [];\r\n            while (!walker.goUntil(93)) { // ]\r\n                var item = {};\r\n                arrItems.push(item);\r\n\r\n                if (walker.source.charCodeAt(walker.index) === 46 && walker.match(/\\.\\.\\.\\s*/g)) {\r\n                    item.spread = true;\r\n                }\r\n\r\n                item.expr = readTertiaryExpr(walker);\r\n                walker.goUntil(44); // ,\r\n            }\r\n\r\n            return {\r\n                type: ExprType.ARRAY,\r\n                items: arrItems\r\n            };\r\n\r\n        // object literal\r\n        case 123: // {\r\n            walker.index++;\r\n            var objItems = [];\r\n\r\n            while (!walker.goUntil(125)) { // }\r\n                var item = {};\r\n                objItems.push(item);\r\n\r\n                if (walker.source.charCodeAt(walker.index) === 46 && walker.match(/\\.\\.\\.\\s*/g)) {\r\n                    item.spread = true;\r\n                    item.expr = readTertiaryExpr(walker);\r\n                }\r\n                else {\r\n                    // #[begin] error\r\n                    var walkerIndexBeforeName = walker.index;\r\n                    // #[end]\r\n\r\n                    item.name = readUnaryExpr(walker);\r\n\r\n                    // #[begin] error\r\n                    if (item.name.type > 4) {\r\n                        throw new Error(\r\n                            '[SAN FATAL] unexpect object name: '\r\n                            + walker.source.slice(walkerIndexBeforeName, walker.index)\r\n                        );\r\n                    }\r\n                    // #[end]\r\n\r\n                    if (walker.goUntil(58)) { // :\r\n                        item.expr = readTertiaryExpr(walker);\r\n                    }\r\n                    else {\r\n                        item.expr = item.name;\r\n                    }\r\n\r\n                    if (item.name.type === ExprType.ACCESSOR) {\r\n                        item.name = item.name.paths[0];\r\n                    }\r\n                }\r\n\r\n                walker.goUntil(44); // ,\r\n            }\r\n\r\n            return {\r\n                type: ExprType.OBJECT,\r\n                items: objItems\r\n            };\r\n    }\r\n\r\n    return readCall(walker);\r\n}","/**\r\n * 表达式类型\r\n *\r\n * @const\r\n * @type {Object}\r\n */\r\n export let ExprType = {\r\n    STRING: 1, //字符串，其中不会包含变量\r\n    NUMBER: 2, // 数，其中不会包含变量\r\n    BOOL: 3, //布尔值，其中不会包含变量\r\n    ACCESSOR: 4, // 对变量的访问，需要重点处理\r\n    INTERP: 5, // 插值，在ACCESSOR基础上，可能增加了filter\r\n    CALL: 6, // 函数调用\r\n    TEXT: 7, // 文本值，字符串的拼接，可能是字符串与其他类型的组合\r\n    BINARY: 8, //二元表达式 类如 || && \r\n    UNARY: 9, // 一元表达式\r\n    TERTIARY: 10, // 三元表达式\r\n    OBJECT: 11, // 对象字面量\r\n    ARRAY: 12, // 数组字面量\r\n    NULL: 13 // null值\r\n};\r\n\r\n//正则表达式\r\n//量词元字符\r\n//* 零到多次\r\n//+ 一到多次\r\n//? 零或者一次\r\n//{n} 出现n次\r\n//{n, } 出现n到多次\r\n//{n, m} 出现n到m次\r\n\r\n\r\n//特殊元字符\r\n//\\ 转义字符\r\n//. 除\\n(换行)以外的任意字符 \r\n//^ 以哪一个元素符作为开始\r\n//$ 以哪一个元素符作为结束\r\n//\\n 换行符\r\n//\\d 0-9之间的任意数字\r\n//\\D 除0-9之间任意数字\r\n//\\w 数字字母，下划线中的任意一个\r\n//\\s 一个空白符(包含制表符，空格，换行符)\r\n//\\t 一个制表符\r\n//\\b 匹配一个单词的边界\r\n//x|y x或者y中的一个字符\r\n//[xyz] x或者y或者z中的任意一个字符\r\n//[^xy] 除了x或者y中的任意一个字符\r\n//[a-z] a到z之间的任意一个字符\r\n//[^a-z] 除了a到z之外的任意一个字符\r\n//() 正则中的分组符号\r\n//(?:) 只匹配不捕获\r\n//(?=) 正向预查\r\n//(?!) 反向预查","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取字符串\r\n */\r\n\r\n import { ExprType } from './expr-type.js';\r\n\r\n/**\r\n * 读取字符串\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readString(walker) {\r\n    var startCode = walker.source.charCodeAt(walker.index);\r\n    var value = \"\";\r\n    var charCode;\r\n\r\n    walkLoop: while ((charCode = walker.nextCode())) {\r\n        switch (charCode) {\r\n            case 92: // \\\r\n                charCode = walker.nextCode();\r\n\r\n                switch (charCode) {\r\n                    case 117: // \\u\r\n                        value += String.fromCharCode(parseInt(\r\n                            walker.source.slice(walker.index + 1, walker.index + 5), 16\r\n                        ));\r\n                        walker.index += 4;\r\n                        break;\r\n\r\n                    case 120: // \\x\r\n                        value += String.fromCharCode(parseInt(\r\n                            walker.source.slice(walker.index + 1, walker.index + 3), 16\r\n                        ));\r\n                        walker.index += 2;\r\n                        break;\r\n\r\n                    case 98:\r\n                        value += '\\b';\r\n                        break;\r\n                    case 102:\r\n                        value += '\\f';\r\n                        break;\r\n                    case 110:\r\n                        value += '\\n';\r\n                        break;\r\n                    case 114:\r\n                        value += '\\r';\r\n                        break;\r\n                    case 116:\r\n                        value += '\\t';\r\n                        break;\r\n                    case 118:\r\n                        value += '\\v';\r\n                        break;\r\n\r\n                    default:\r\n                        value += String.fromCharCode(charCode);\r\n                }\r\n\r\n                break;\r\n            case startCode:\r\n                walker.index++;\r\n                break walkLoop;\r\n            default:\r\n                value += String.fromCharCode(charCode);\r\n        }\r\n    }\r\n\r\n    return {\r\n        type: ExprType.STRING,\r\n        // 处理字符转义\r\n        value: value\r\n    };\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取括号表达式\r\n */\r\n\r\nimport { readTertiaryExpr } from './read-tertiary-expr.js';\r\n\r\n/**\r\n * 读取括号表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readParenthesizedExpr(walker) {\r\n    walker.index++;\r\n    var expr = readTertiaryExpr(walker);\r\n    walker.goUntil(41); // )\r\n\r\n    expr.parenthesized = true;\r\n    return expr;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取调用\r\n */\r\n\r\nimport { ExprType } from './expr-type.js';\r\nimport { readAccessor } from './read-accessor.js';\r\nimport { readTertiaryExpr } from './read-tertiary-expr.js';\r\n\r\n/**\r\n * 读取调用\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @param {Array=} defaultArgs 默认参数\r\n * @return {Object}\r\n */\r\nexport function readCall(walker, defaultArgs) {\r\n    walker.goUntil();\r\n    var result = readAccessor(walker);\r\n\r\n    var args;\r\n    if (walker.goUntil(40)) { // (\r\n        args = [];\r\n\r\n        while (!walker.goUntil(41)) { // )\r\n            args.push(readTertiaryExpr(walker));\r\n            walker.goUntil(44); // ,\r\n        }\r\n    }\r\n    else if (defaultArgs) {\r\n        args = defaultArgs;\r\n    }\r\n\r\n    if (args) {\r\n        result = {\r\n            type: ExprType.CALL,\r\n            name: result,\r\n            args: args\r\n        };\r\n    }\r\n\r\n    return result;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取访问表达式\r\n */\r\n\r\nimport { ExprType } from './expr-type.js';\r\nimport { readIdent } from './read-ident.js';\r\nimport { readTertiaryExpr } from './read-tertiary-expr.js';\r\n\r\n/**\r\n * 读取访问表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readAccessor(walker) {\r\n    var firstSeg = readIdent(walker);\r\n    switch (firstSeg) {\r\n        case 'true':\r\n        case 'false':\r\n            return {\r\n                type: ExprType.BOOL,\r\n                value: firstSeg === 'true'\r\n            };\r\n        case 'null':\r\n            return {\r\n                type: ExprType.NULL\r\n            };\r\n    }\r\n\r\n    var result = {\r\n        type: ExprType.ACCESSOR,\r\n        paths: [\r\n            {type: ExprType.STRING, value: firstSeg}\r\n        ]\r\n    };\r\n\r\n    /* eslint-disable no-constant-condition */\r\n    accessorLoop: while (1) {\r\n    /* eslint-enable no-constant-condition */\r\n\r\n        switch (walker.source.charCodeAt(walker.index)) {\r\n            case 46: // .\r\n                walker.index++;\r\n\r\n                // ident as string\r\n                result.paths.push({\r\n                    type: ExprType.STRING,\r\n                    value: readIdent(walker)\r\n                });\r\n                break;\r\n\r\n            case 91: // [\r\n                walker.index++;\r\n                result.paths.push(readTertiaryExpr(walker));\r\n                walker.goUntil(93); // ]\r\n                break;\r\n\r\n            default:\r\n                break accessorLoop;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取乘法表达式\r\n */\r\nimport { ExprType } from './expr-type.js';\r\nimport { readUnaryExpr } from './read-unary-expr.js';\r\n\r\n/**\r\n * 读取乘法表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readMultiplicativeExpr(walker) {\r\n    var expr = readUnaryExpr(walker);\r\n\r\n    while (1) {\r\n        walker.goUntil();\r\n\r\n        var code = walker.source.charCodeAt(walker.index);\r\n        switch (code) {\r\n            case 37: // %\r\n            case 42: // *\r\n            case 47: // /\r\n                walker.index++;\r\n                expr = {\r\n                    type: ExprType.BINARY,\r\n                    operator: code,\r\n                    segs: [expr, readUnaryExpr(walker)]\r\n                };\r\n                continue;\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    return expr;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取加法表达式\r\n */\r\n\r\nimport { ExprType } from './expr-type.js';\r\nimport { readMultiplicativeExpr } from './read-multiplicative-expr.js';\r\n\r\n\r\n/**\r\n * 读取加法表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readAdditiveExpr(walker) {\r\n    var expr = readMultiplicativeExpr(walker);\r\n\r\n    while (1) {\r\n        walker.goUntil();\r\n        var code = walker.source.charCodeAt(walker.index);\r\n\r\n        switch (code) {\r\n            case 43: // +\r\n            case 45: // -\r\n                walker.index++;\r\n                expr = {\r\n                    type: ExprType.BINARY,\r\n                    operator: code,\r\n                    segs: [expr, readMultiplicativeExpr(walker)]\r\n                };\r\n                continue;\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    return expr;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取关系判断表达式\r\n */\r\nimport { ExprType } from './expr-type.js';\r\nimport { readAdditiveExpr } from './read-additive-expr.js';\r\n\r\n/**\r\n * 读取关系判断表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readRelationalExpr(walker) {\r\n    var expr = readAdditiveExpr(walker);\r\n    walker.goUntil();\r\n\r\n    var code = walker.source.charCodeAt(walker.index);\r\n    switch (code) {\r\n        case 60: // <\r\n        case 62: // >\r\n            if (walker.nextCode() === 61) {\r\n                code += 61;\r\n                walker.index++;\r\n            }\r\n\r\n            return {\r\n                type: ExprType.BINARY,\r\n                operator: code,\r\n                segs: [expr, readAdditiveExpr(walker)]\r\n            };\r\n    }\r\n\r\n    return expr;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取逻辑与表达式\r\n */\r\nimport { ExprType } from './expr-type.js';\r\nimport { readEqualityExpr } from './read-equality-expr.js';\r\n\r\n/**\r\n * 读取逻辑与表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readLogicalANDExpr(walker) {\r\n    var expr = readEqualityExpr(walker);\r\n    walker.goUntil();\r\n\r\n    if (walker.source.charCodeAt(walker.index) === 38) { // &\r\n        if (walker.nextCode() === 38) {\r\n            walker.index++;\r\n            return {\r\n                type: ExprType.BINARY,\r\n                operator: 76,\r\n                segs: [expr, readLogicalANDExpr(walker)]\r\n            };\r\n        }\r\n\r\n        walker.index--;\r\n    }\r\n\r\n    return expr;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取相等比对表达式\r\n */\r\n\r\nimport { ExprType } from './expr-type.js';\r\nimport { readRelationalExpr } from './read-relational-expr.js';\r\n\r\n/**\r\n * 读取相等比对表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readEqualityExpr(walker) {\r\n    var expr = readRelationalExpr(walker);\r\n    walker.goUntil();\r\n\r\n    var code = walker.source.charCodeAt(walker.index);\r\n    switch (code) {\r\n        case 61: // =\r\n        case 33: // !\r\n            if (walker.nextCode() === 61) {\r\n                code += 61;\r\n                if (walker.nextCode() === 61) {\r\n                    code += 61;\r\n                    walker.index++;\r\n                }\r\n\r\n                return {\r\n                    type: ExprType.BINARY,\r\n                    operator: code,\r\n                    segs: [expr, readRelationalExpr(walker)]\r\n                };\r\n            }\r\n\r\n            walker.index--;\r\n    }\r\n\r\n    return expr;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取逻辑或表达式\r\n */\r\nimport { ExprType } from './expr-type.js';\r\nimport { readLogicalANDExpr } from './read-logical-and-expr.js';\r\n\r\n/**\r\n * 读取逻辑或表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readLogicalORExpr(walker) {\r\n    var expr = readLogicalANDExpr(walker);\r\n    walker.goUntil();\r\n\r\n    if (walker.source.charCodeAt(walker.index) === 124) { // |\r\n        if (walker.nextCode() === 124) {\r\n            walker.index++;\r\n            return {\r\n                type: ExprType.BINARY,\r\n                operator: 248,\r\n                segs: [expr, readLogicalORExpr(walker)]\r\n            };\r\n        }\r\n\r\n        walker.index--;\r\n    }\r\n\r\n    return expr;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取三元表达式\r\n */\r\n\r\nimport { ExprType } from './expr-type.js';\r\nimport { readLogicalORExpr } from './read-logical-or-expr.js';\r\n\r\n/**\r\n * 读取三元表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readTertiaryExpr(walker) {\r\n    var conditional = readLogicalORExpr(walker);\r\n    walker.goUntil();\r\n\r\n    if (walker.source.charCodeAt(walker.index) === 63) { // ?\r\n        walker.index++;\r\n        var yesExpr = readTertiaryExpr(walker);\r\n        walker.goUntil();\r\n\r\n        if (walker.source.charCodeAt(walker.index) === 58) { // :\r\n            walker.index++;\r\n            return {\r\n                type: ExprType.TERTIARY,\r\n                segs: [\r\n                    conditional,\r\n                    yesExpr,\r\n                    readTertiaryExpr(walker)\r\n                ]\r\n            };\r\n        }\r\n    }\r\n\r\n    return conditional;\r\n}","/**\r\n *\r\n * @file 字符串源码读取类\r\n */\r\n\r\n\r\n/**\r\n * 字符串源码读取类，用于模板字符串解析过程\r\n *\r\n * @class\r\n * @param {string} source 要读取的字符串\r\n */\r\nexport function Walker (source) {\r\n    this.source = source\r\n    this.len = source.length\r\n    this.index = 0\r\n}\r\n\r\n/**\r\n * 读取下一个字符，返回下一个字符的 code\r\n *\r\n * @return {number}\r\n */\r\nWalker.prototype.nextCode = function () {\r\n    this.index++\r\n    return this.source.charCodeAt(this.index)\r\n}\r\n\r\n/**\r\n * 向前读取字符，直到遇到指定字符再停止\r\n * 未指定字符时，当遇到第一个非空格、制表符的字符停止\r\n *\r\n * @param {number=} charCode 指定字符的code\r\n * @return {boolean} 当指定字符时，返回是否碰到指定的字符\r\n */\r\nWalker.prototype.goUntil = function (charCode) {\r\n    let code\r\n    while(this.index < this.len && (code = this.source.charCodeAt(this.index))){\r\n        switch(code){\r\n            case 32: //空格\r\n            case 9: //制表\r\n            case 13: // \\r\r\n            case 10: // \\n\r\n                this.index++\r\n                break;\r\n            default:\r\n                if(code === charCode){\r\n                    this.index++\r\n                    return 1\r\n                }\r\n                return\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * 向前读取符合规则的字符片段，并返回规则匹配结果\r\n *\r\n * @param {RegExp} reg 字符片段的正则表达式\r\n * @param {boolean} isMatchStart 是否必须匹配当前位置\r\n * @return {Array?}\r\n */\r\nWalker.prototype.match = function (reg, isMatchStart) {\r\n    reg.lastIndex = this.index\r\n\r\n    let match = reg.exec(this.source)\r\n    console.log('match', match)\r\n\r\n    if(match && (!isMatchStart || this.index === match.index)){\r\n        this.index = reg.lastIndex\r\n        return match\r\n    }\r\n}","import { readTertiaryExpr } from './read-tertiary-expr.js'\r\nimport { Walker } from './walker.js'\r\n/**\r\n * 解析表达式\r\n *\r\n * @param {string} source 源码\r\n * @return {Object}\r\n */\r\nexport function parseExpr (source) {\r\n    if(!source){\r\n        return\r\n    }\r\n\r\n    if(typeof source === 'object' && source.type){\r\n        return source\r\n    }\r\n\r\n    return readTertiaryExpr(new Walker(source));\r\n}","import { parseExpr } from '../parser/parse-Expr.js'\r\n//响应式数据方法\r\n//parent为父级数据\r\n//data为初始数据\r\n//listeners为收集数据发生改变的容器\r\nfunction Data (data, parent) {\r\n    this.parent = parent\r\n    this.raw = data || {}\r\n    this.listeners = []\r\n}\r\n\r\n//该方法为获取数据\r\n/**\r\n * 获取数据项\r\n *\r\n * @param {string|Object?} expr 数据项路径\r\n * @param {Data?} callee 当前数据获取的调用环境\r\n * @return {*}\r\n */\r\nData.prototype.get = function (expr, callee) {\r\n    let value = this.raw\r\n    //判断第一个参数有没有传，没传直接返回整个数据\r\n    if(!expr){\r\n        return value\r\n    }\r\n    //不是对象我们需要对他进行处理，得到数据路径\r\n    if(typeof expr !== 'object'){\r\n        expr = parseExpr(expr)\r\n    }\r\n\r\n    let paths = expr.paths\r\n    callee = callee || this\r\n\r\n    //拿解析到的数据路径的第一个key，到原始数据中去找对应的key\r\n    value = value[paths[0].value]\r\n    if(typeof value === 'undefined' && this.parent){\r\n        value = this.parent.get(expr, callee)\r\n    }else{\r\n        for(let i = 1,l = paths.length;value !== null && i < l;i++){\r\n            value = value[paths[i].value]\r\n        }\r\n    }\r\n\r\n    return value\r\n}\r\n\r\n/**\r\n * 数据对象变更操作\r\n *\r\n * @inner\r\n * @param {Object|Array} source 要变更的源数据\r\n * @param {Array} exprPaths 属性路径\r\n * @param {number} pathsStart 当前处理的属性路径指针位置\r\n * @param {number} pathsLen 属性路径长度\r\n * @param {*} value 变更属性值\r\n * @param {Data} data 对应的Data对象\r\n * @return {*} 变更后的新数据\r\n */\r\nData.prototype.immutableSet = function (source, exprPaths, pathsStart, pathsLen, value, data) {\r\n\r\n}\r\n\r\n//改变数据\r\n/**\r\n * 设置数据项\r\n *\r\n * @param {string|Object} expr 数据项路径\r\n * @param {*} value 数据值\r\n * @param {Object=} option 设置参数\r\n * @param {boolean} option.silent 静默设置，不触发变更事件\r\n */\r\nData.prototype.set = function (expr, value, option) {\r\n\r\n}\r\n\r\nexport default Data","import Data from './runtime/data.js'\r\nimport { parseExpr } from './parser/parse-Expr.js'\r\n\r\nlet san = {\r\n    version: '1.0.0',\r\n\r\n    /**\r\n         * 解析表达式\r\n         *\r\n         * @param {string} source 源码\r\n         * @return {Object}\r\n         */\r\n     parseExpr: parseExpr,\r\n\r\n    /**\r\n     * 数据类\r\n     *\r\n     * @class\r\n     * @param {Object?} data 初始数据\r\n     * @param {Data?} parent 父级数据对象\r\n     */\r\n    Data: Data\r\n}\r\nif(typeof window !== 'undefined') window.san = san\r\nexport default san"],"names":["readIdent","walker","match","Error","source","slice","index","readUnaryExpr","goUntil","currentCode","charCodeAt","expr","operator","value","type","postUnaryExpr","charCode","startCode","walkLoop","nextCode","String","fromCharCode","parseInt","readString","readTertiaryExpr","parenthesized","readParenthesizedExpr","arrItems","item","push","spread","items","objItems","walkerIndexBeforeName","name","paths","defaultArgs","args","result","firstSeg","accessorLoop","readAccessor","readCall","readMultiplicativeExpr","code","segs","readAdditiveExpr","readRelationalExpr","readLogicalANDExpr","readEqualityExpr","readLogicalORExpr","conditional","yesExpr","Walker","this","len","length","parseExpr","Data","data","parent","raw","listeners","prototype","reg","isMatchStart","lastIndex","exec","console","log","get","callee","i","l","immutableSet","exprPaths","pathsStart","pathsLen","set","option","san","version","window"],"sourceRoot":""}