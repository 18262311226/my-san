{"version":3,"file":"main.js","mappings":"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","sources":["webpack://my-san/./src/parser/read-ident.js","webpack://my-san/./src/parser/read-unary-expr.js","webpack://my-san/./src/parser/expr-type.js","webpack://my-san/./src/parser/read-string.js","webpack://my-san/./src/parser/read-parenthesized-expr.js","webpack://my-san/./src/parser/read-call.js","webpack://my-san/./src/parser/read-accessor.js","webpack://my-san/./src/parser/read-multiplicative-expr.js","webpack://my-san/./src/parser/read-additive-expr.js","webpack://my-san/./src/parser/read-relational-expr.js","webpack://my-san/./src/parser/read-logical-and-expr.js","webpack://my-san/./src/parser/read-equality-expr.js","webpack://my-san/./src/parser/read-logical-or-expr.js","webpack://my-san/./src/parser/read-tertiary-expr.js","webpack://my-san/./src/parser/walker.js","webpack://my-san/./src/parser/parse-Expr.js","webpack://my-san/./src/runtime/eval-expr.js","webpack://my-san/./src/runtime/data.js","webpack://my-san/./src/main.js"],"sourcesContent":["/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取ident\r\n */\r\n\r\n/**\r\n * 读取ident\r\n * 这里的 ident 指标识符(identifier)，也就是通常意义上的变量名\r\n * 这里默认的变量名规则为：由美元符号($)、数字、字母或者下划线(_)构成的字符串\r\n *\r\n * @inner\r\n * @param {Walker} walker 源码读取对象\r\n * @return {string}\r\n */\r\nexport function readIdent(walker) { \r\n    //匹配变量名称\r\n    var match = walker.match(/\\s*([\\$0-9a-z_]+)/ig, 1);\r\n\r\n    // #[begin] error\r\n    //如果match为空，证明没有匹配到，直接抛出异常\r\n    if (!match) {\r\n        throw new Error('[SAN FATAL] expect an ident: ' + walker.source.slice(walker.index));\r\n    }\r\n    // #[end]\r\n    //返回匹配到的结果\r\n    return match[1];\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取一元表达式\r\n */\r\nimport { ExprType } from './expr-type.js';\r\nimport {readString } from './read-string.js';\r\nimport { readCall } from './read-call.js';\r\nimport { readParenthesizedExpr } from './read-parenthesized-expr.js';\r\nimport { readTertiaryExpr } from './read-tertiary-expr.js'; \r\n\r\nfunction postUnaryExpr(expr, operator) {\r\n    switch (operator) {\r\n        case 33:\r\n            var value;\r\n            switch (expr.type) {\r\n                case ExprType.NUMBER:\r\n                case ExprType.STRING:\r\n                case ExprType.BOOL:\r\n                    value = !expr.value;\r\n                    break;\r\n                case ExprType.ARRAY:\r\n                case ExprType.OBJECT:\r\n                    value = false;\r\n                    break;\r\n                case ExprType.NULL:\r\n                    value = true;\r\n                    break;\r\n            }\r\n\r\n            if (value != null) {\r\n                return {\r\n                    type: ExprType.BOOL,\r\n                    value: value\r\n                };\r\n            }\r\n            break;\r\n\r\n        case 43:\r\n            switch (expr.type) {\r\n                case ExprType.NUMBER:\r\n                case ExprType.STRING:\r\n                case ExprType.BOOL:\r\n                    return {\r\n                        type: ExprType.NUMBER,\r\n                        value: +expr.value\r\n                    };\r\n            }\r\n            break;\r\n\r\n        case 45:\r\n            switch (expr.type) {\r\n                case ExprType.NUMBER:\r\n                case ExprType.STRING:\r\n                case ExprType.BOOL:\r\n                    return {\r\n                        type: ExprType.NUMBER,\r\n                        value: -expr.value\r\n                    };\r\n            }\r\n            break;\r\n    }\r\n\r\n    return {\r\n        type: ExprType.UNARY,\r\n        expr: expr,\r\n        operator: operator\r\n    };\r\n}\r\n\r\n/**\r\n * 读取一元表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readUnaryExpr(walker) {\r\n    walker.goUntil();//跳过空白，制表符\r\n\r\n    var currentCode = walker.source.charCodeAt(walker.index);\r\n    //一元表达式也有可能出现前面带符号的\r\n    switch (currentCode) {\r\n        case 33: // !\r\n        case 43: // +\r\n        case 45: // -\r\n            walker.index++;\r\n            return postUnaryExpr(readUnaryExpr(walker), currentCode);\r\n\r\n        case 34: // \"\r\n        case 39: // '\r\n            return readString(walker);\r\n\r\n        case 48: // number\r\n        case 49:\r\n        case 50:\r\n        case 51:\r\n        case 52:\r\n        case 53:\r\n        case 54:\r\n        case 55:\r\n        case 56:\r\n        case 57:\r\n            return {\r\n                type: ExprType.NUMBER,\r\n                value: +(walker.match(/[0-9]+(\\.[0-9]+)?/g, 1)[0])\r\n            };\r\n\r\n        case 40: // (\r\n            return readParenthesizedExpr(walker);\r\n\r\n        // array literal\r\n        case 91: // [\r\n            walker.index++;\r\n            var arrItems = [];\r\n            while (!walker.goUntil(93)) { // ]\r\n                var item = {};\r\n                arrItems.push(item);\r\n\r\n                if (walker.source.charCodeAt(walker.index) === 46 && walker.match(/\\.\\.\\.\\s*/g)) {\r\n                    item.spread = true;\r\n                }\r\n\r\n                item.expr = readTertiaryExpr(walker);\r\n                walker.goUntil(44); // ,\r\n            }\r\n\r\n            return {\r\n                type: ExprType.ARRAY,\r\n                items: arrItems\r\n            };\r\n\r\n        // object literal\r\n        case 123: // {\r\n            walker.index++;\r\n            var objItems = [];\r\n\r\n            while (!walker.goUntil(125)) { // }\r\n                var item = {};\r\n                objItems.push(item);\r\n\r\n                if (walker.source.charCodeAt(walker.index) === 46 && walker.match(/\\.\\.\\.\\s*/g)) {\r\n                    item.spread = true;\r\n                    item.expr = readTertiaryExpr(walker);\r\n                }\r\n                else {\r\n                    // #[begin] error\r\n                    var walkerIndexBeforeName = walker.index;\r\n                    // #[end]\r\n\r\n                    item.name = readUnaryExpr(walker);\r\n\r\n                    // #[begin] error\r\n                    if (item.name.type > 4) {\r\n                        throw new Error(\r\n                            '[SAN FATAL] unexpect object name: '\r\n                            + walker.source.slice(walkerIndexBeforeName, walker.index)\r\n                        );\r\n                    }\r\n                    // #[end]\r\n\r\n                    if (walker.goUntil(58)) { // :\r\n                        item.expr = readTertiaryExpr(walker);\r\n                    }\r\n                    else {\r\n                        item.expr = item.name;\r\n                    }\r\n\r\n                    if (item.name.type === ExprType.ACCESSOR) {\r\n                        item.name = item.name.paths[0];\r\n                    }\r\n                }\r\n\r\n                walker.goUntil(44); // ,\r\n            }\r\n\r\n            return {\r\n                type: ExprType.OBJECT,\r\n                items: objItems\r\n            };\r\n    }\r\n\r\n    return readCall(walker);\r\n}","/**\r\n * 表达式类型\r\n *\r\n * @const\r\n * @type {Object}\r\n */\r\n export let ExprType = {\r\n    STRING: 1, //字符串，其中不会包含变量\r\n    NUMBER: 2, // 数，其中不会包含变量\r\n    BOOL: 3, //布尔值，其中不会包含变量\r\n    ACCESSOR: 4, // 对变量的访问，需要重点处理\r\n    INTERP: 5, // 插值，在ACCESSOR基础上，可能增加了filter\r\n    CALL: 6, // 函数调用\r\n    TEXT: 7, // 文本值，字符串的拼接，可能是字符串与其他类型的组合\r\n    BINARY: 8, //二元表达式 类如 || && \r\n    UNARY: 9, // 一元表达式\r\n    TERTIARY: 10, // 三元表达式\r\n    OBJECT: 11, // 对象字面量\r\n    ARRAY: 12, // 数组字面量\r\n    NULL: 13 // null值\r\n};\r\n\r\n//正则表达式\r\n//量词元字符\r\n//* 零到多次\r\n//+ 一到多次\r\n//? 零或者一次\r\n//{n} 出现n次\r\n//{n, } 出现n到多次\r\n//{n, m} 出现n到m次\r\n\r\n\r\n//特殊元字符\r\n//\\ 转义字符\r\n//. 除\\n(换行)以外的任意字符 \r\n//^ 以哪一个元素符作为开始\r\n//$ 以哪一个元素符作为结束\r\n//\\n 换行符\r\n//\\d 0-9之间的任意数字\r\n//\\D 除0-9之间任意数字\r\n//\\w 数字字母，下划线中的任意一个\r\n//\\s 一个空白符(包含制表符，空格，换行符)\r\n//\\t 一个制表符\r\n//\\b 匹配一个单词的边界\r\n//x|y x或者y中的一个字符\r\n//[xyz] x或者y或者z中的任意一个字符\r\n//[^xy] 除了x或者y中的任意一个字符\r\n//[a-z] a到z之间的任意一个字符\r\n//[^a-z] 除了a到z之外的任意一个字符\r\n//() 正则中的分组符号\r\n//(?:) 只匹配不捕获\r\n//(?=) 正向预查\r\n//(?!) 反向预查","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取字符串\r\n */\r\n\r\n import { ExprType } from './expr-type.js';\r\n\r\n/**\r\n * 读取字符串\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readString(walker) {\r\n    var startCode = walker.source.charCodeAt(walker.index); //拿到当前字符的编码\r\n    var value = \"\";\r\n    var charCode;\r\n\r\n    //拿到下一个字符编码，有就开始循环\r\n    walkLoop: while ((charCode = walker.nextCode())) {\r\n        switch (charCode) {\r\n            case 92: // \\ \r\n                charCode = walker.nextCode();\r\n\r\n                switch (charCode) {\r\n                    case 117: // \\u\r\n                        value += String.fromCharCode(parseInt(\r\n                            walker.source.slice(walker.index + 1, walker.index + 5), 16\r\n                        ));\r\n                        walker.index += 4;\r\n                        break;\r\n\r\n                    case 120: // \\x\r\n                        value += String.fromCharCode(parseInt(\r\n                            walker.source.slice(walker.index + 1, walker.index + 3), 16\r\n                        ));\r\n                        walker.index += 2;\r\n                        break;\r\n\r\n                    case 98:\r\n                        value += '\\b';\r\n                        break;\r\n                    case 102:\r\n                        value += '\\f';\r\n                        break;\r\n                    case 110:\r\n                        value += '\\n';\r\n                        break;\r\n                    case 114:\r\n                        value += '\\r';\r\n                        break;\r\n                    case 116:\r\n                        value += '\\t';\r\n                        break;\r\n                    case 118:\r\n                        value += '\\v';\r\n                        break;\r\n\r\n                    default:\r\n                        value += String.fromCharCode(charCode);\r\n                }\r\n\r\n                break;\r\n            case startCode:\r\n                walker.index++;\r\n                break walkLoop;\r\n            default:\r\n                value += String.fromCharCode(charCode);\r\n        }\r\n    }\r\n\r\n    return {\r\n        type: ExprType.STRING,\r\n        // 处理字符转义\r\n        value: value\r\n    };\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取括号表达式\r\n */\r\n\r\nimport { readTertiaryExpr } from './read-tertiary-expr.js';\r\n\r\n/**\r\n * 读取括号表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readParenthesizedExpr(walker) {\r\n    walker.index++;\r\n    //看括号内容从是否是三元表达式开始\r\n    var expr = readTertiaryExpr(walker);\r\n    walker.goUntil(41); // ) index跳到右括号位置\r\n    expr.parenthesized = true; //此字段为括号表达式， true则表示是\r\n    return expr;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取调用\r\n */\r\n\r\nimport { ExprType } from './expr-type.js';\r\nimport { readAccessor } from './read-accessor.js';\r\nimport { readTertiaryExpr } from './read-tertiary-expr.js';\r\n\r\n/**\r\n * 读取调用\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @param {Array=} defaultArgs 默认参数\r\n * @return {Object}\r\n */\r\nexport function readCall(walker, defaultArgs) {\r\n    walker.goUntil();//跳过空白符，制表符\r\n    var result = readAccessor(walker);//进入对象访问解析函数，并拿到结果\r\n\r\n    var args;\r\n    if (walker.goUntil(40)) { // ( index跳过空白，指标符找到左括号\r\n        args = []; //\r\n\r\n        while (!walker.goUntil(41)) { // ) \r\n            args.push(readTertiaryExpr(walker));\r\n            walker.goUntil(44); // ,\r\n        }\r\n    }\r\n    else if (defaultArgs) {\r\n        args = defaultArgs;\r\n    }\r\n\r\n    if (args) {\r\n        result = {\r\n            type: ExprType.CALL,\r\n            name: result,\r\n            args: args\r\n        };\r\n    }\r\n\r\n    return result;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取访问表达式\r\n */\r\n\r\nimport { ExprType } from './expr-type.js';\r\nimport { readIdent } from './read-ident.js';\r\nimport { readTertiaryExpr } from './read-tertiary-expr.js';\r\n\r\n/**\r\n * 读取访问表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readAccessor(walker) {\r\n    var firstSeg = readIdent(walker);//读取到变量名\r\n    switch (firstSeg) {\r\n        case 'true':\r\n        case 'false':\r\n            return {\r\n                type: ExprType.BOOL,\r\n                value: firstSeg === 'true'\r\n            };\r\n        case 'null':\r\n            return {\r\n                type: ExprType.NULL\r\n            };\r\n    }\r\n\r\n    //如果上面没有走到上面的switch，就直接反回是个对变量的访问，paths就是路径，存储的就是一个类型为字符串，值是变量名\r\n    //let obj = {\r\n    //  name:'liu',\r\n    //  age: 18,\r\n    //  child: {\r\n    //      name: 'xliu'\r\n    //  }\r\n    //}\r\n    // child.name 第一次匹配到value为child\r\n    var result = {\r\n        type: ExprType.ACCESSOR,\r\n        paths: [\r\n            {type: ExprType.STRING, value: firstSeg}\r\n        ]\r\n    };\r\n\r\n    /* eslint-disable no-constant-condition */\r\n    accessorLoop: while (1) {\r\n    /* eslint-enable no-constant-condition */\r\n        //正则表达式匹配完之后lastIndex之后自动跳到下一个\r\n        switch (walker.source.charCodeAt(walker.index)) {\r\n            case 46: // . 如果匹配到点，就说明是对象访问的方式\r\n                walker.index++; //跳到下一个\r\n\r\n                // ident as string\r\n                //继续看是否是对象访问方式\r\n                result.paths.push({\r\n                    type: ExprType.STRING,\r\n                    value: readIdent(walker)\r\n                });\r\n                break;\r\n            //如果是中括号，则先看内容是否为三元表达式\r\n            case 91: // [\r\n                walker.index++;\r\n                result.paths.push(readTertiaryExpr(walker));\r\n                walker.goUntil(93); // ]  跳过右中括号\r\n                break;\r\n\r\n            default:\r\n                break accessorLoop;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取乘法表达式\r\n */\r\nimport { ExprType } from './expr-type.js';\r\nimport { readUnaryExpr } from './read-unary-expr.js';\r\n\r\n/**\r\n * 读取乘法表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readMultiplicativeExpr(walker) {\r\n    var expr = readUnaryExpr(walker); //解析一元表达式开始，并拿到返回结果\r\n    //这里和加减解析一样\r\n    while (1) {\r\n        walker.goUntil();\r\n\r\n        var code = walker.source.charCodeAt(walker.index);\r\n        switch (code) {\r\n            case 37: // %\r\n            case 42: // *\r\n            case 47: // /\r\n                walker.index++;\r\n                expr = {\r\n                    type: ExprType.BINARY,\r\n                    operator: code,\r\n                    segs: [expr, readUnaryExpr(walker)]\r\n                };\r\n                continue;\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    return expr;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取加法表达式\r\n */\r\n\r\nimport { ExprType } from './expr-type.js';\r\nimport { readMultiplicativeExpr } from './read-multiplicative-expr.js';\r\n\r\n\r\n/**\r\n * 读取加法表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readAdditiveExpr(walker) {\r\n    var expr = readMultiplicativeExpr(walker);//从乘除取余开始，并拿到返回结果\r\n\r\n    while (1) {//这个循环有点多余，不知道啥意思，也只循环一次\r\n        walker.goUntil();\r\n        var code = walker.source.charCodeAt(walker.index);\r\n\r\n        switch (code) {\r\n            case 43: // +\r\n            case 45: // -\r\n                walker.index++;\r\n                expr = {\r\n                    type: ExprType.BINARY,\r\n                    operator: code,\r\n                    segs: [expr, readMultiplicativeExpr(walker)]\r\n                };\r\n                continue;\r\n        }\r\n\r\n        break;\r\n    }\r\n    //不是加减则返回乘除函数结果\r\n    return expr;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取关系判断表达式\r\n */\r\nimport { ExprType } from './expr-type.js';\r\nimport { readAdditiveExpr } from './read-additive-expr.js';\r\n\r\n/**\r\n * 读取关系判断表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readRelationalExpr(walker) {\r\n    var expr = readAdditiveExpr(walker); //从加减解析函数开始，并拿到返回值结果\r\n    walker.goUntil();//index跳过所有空白，制表符\r\n\r\n    var code = walker.source.charCodeAt(walker.index);//拿到当前字符编码\r\n    switch (code) {\r\n        case 60: // <\r\n        case 62: // >\r\n            if (walker.nextCode() === 61) { //如果是等于号\r\n                code += 61; //字符编码加上等于号编码\r\n                walker.index++;\r\n            }\r\n            //无论是大于还是小于有没有等于号都返回关系表达式\r\n            return {\r\n                type: ExprType.BINARY,\r\n                operator: code,\r\n                segs: [expr, readAdditiveExpr(walker)]\r\n            };\r\n    }\r\n    //不是关系表达式则返回加减函数返回的结果\r\n    return expr;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取逻辑与表达式\r\n */\r\nimport { ExprType } from './expr-type.js';\r\nimport { readEqualityExpr } from './read-equality-expr.js';\r\n\r\n/**\r\n * 读取逻辑与表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readLogicalANDExpr(walker) {\r\n    var expr = readEqualityExpr(walker);//从相等解析入口开始，并拿到返回结果\r\n    walker.goUntil();\r\n\r\n    if (walker.source.charCodeAt(walker.index) === 38) { // &\r\n        if (walker.nextCode() === 38) {\r\n            walker.index++;\r\n            //返回二元表达式\r\n            return {\r\n                type: ExprType.BINARY,\r\n                operator: 76,\r\n                segs: [expr, readLogicalANDExpr(walker)]\r\n            };\r\n        }\r\n\r\n        walker.index--;\r\n    }\r\n    //不是与运算则返回相等解析函数返回的结果\r\n    return expr;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取相等比对表达式\r\n */\r\n\r\nimport { ExprType } from './expr-type.js';\r\nimport { readRelationalExpr } from './read-relational-expr.js';\r\n\r\n/**\r\n * 读取相等比对表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readEqualityExpr(walker) {\r\n    var expr = readRelationalExpr(walker);//从关系表达式解析函数开始，并拿到返回结果\r\n    walker.goUntil();\r\n\r\n    var code = walker.source.charCodeAt(walker.index);\r\n    switch (code) {\r\n        case 61: // =\r\n        case 33: // !\r\n            if (walker.nextCode() === 61) {\r\n                code += 61;\r\n                if (walker.nextCode() === 61) {\r\n                    code += 61;\r\n                    walker.index++;\r\n                }\r\n                //返回二元表达式结果\r\n                return {\r\n                    type: ExprType.BINARY,\r\n                    operator: code,\r\n                    segs: [expr, readRelationalExpr(walker)]\r\n                };\r\n            }\r\n\r\n            walker.index--;\r\n    }\r\n    //如果不是相等则返回关系表达式函数返回的结果\r\n    return expr;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取逻辑或表达式\r\n */\r\nimport { ExprType } from './expr-type.js';\r\nimport { readLogicalANDExpr } from './read-logical-and-expr.js';\r\n\r\n/**\r\n * 读取逻辑或表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readLogicalORExpr(walker) {\r\n    var expr = readLogicalANDExpr(walker); //从与运算解析开始向下\r\n    walker.goUntil();\r\n\r\n    if (walker.source.charCodeAt(walker.index) === 124) { // |\r\n        if (walker.nextCode() === 124) { //如果还是| 则是或运算\r\n            walker.index++;\r\n            //返回二元表达式\r\n            return {\r\n                type: ExprType.BINARY,\r\n                operator: 248,\r\n                segs: [expr, readLogicalORExpr(walker)]\r\n            };\r\n        }\r\n\r\n        walker.index--;\r\n    }\r\n    //不是或运算则返回与解析函数返回的结果\r\n    return expr;\r\n}","/**\r\n * Copyright (c) Baidu Inc. All rights reserved.\r\n *\r\n * This source code is licensed under the MIT license.\r\n * See LICENSE file in the project root for license information.\r\n *\r\n * @file 读取三元表达式\r\n */\r\n\r\nimport { ExprType } from './expr-type.js';\r\nimport { readLogicalORExpr } from './read-logical-or-expr.js';\r\n\r\n/**\r\n * 读取三元表达式\r\n *\r\n * @param {Walker} walker 源码读取对象\r\n * @return {Object}\r\n */\r\nexport function readTertiaryExpr(walker) {\r\n    var conditional = readLogicalORExpr(walker); //进入或运算解析函数\r\n    walker.goUntil(); //下标跳过所有空白，制表符\r\n\r\n    //拿到当前字符编码是否是？\r\n    if (walker.source.charCodeAt(walker.index) === 63) { // ?\r\n        walker.index++; //下标继续向前走\r\n        var yesExpr = readTertiaryExpr(walker); //仍然有可能是三元表达式\r\n        walker.goUntil();//跳过所有空白符，制表符\r\n        //拿到当前字符编码是否是 :\r\n        if (walker.source.charCodeAt(walker.index) === 58) { // :\r\n            walker.index++; //下标继续向前走\r\n            //返回三元表达式对象\r\n            return {\r\n                type: ExprType.TERTIARY,\r\n                segs: [\r\n                    conditional,//或运算方法返回的结果\r\n                    yesExpr,\r\n                    readTertiaryExpr(walker)\r\n                ]\r\n            };\r\n        }\r\n    }\r\n    //不是则返回或运算规则入口返回的对象\r\n    return conditional;\r\n}","/**\r\n *\r\n * @file 字符串源码读取类\r\n */\r\n\r\n\r\n/**\r\n * 字符串源码读取类，用于模板字符串解析过程\r\n *\r\n * @class\r\n * @param {string} source 要读取的字符串\r\n */\r\nexport function Walker (source) {\r\n    this.source = source\r\n    this.len = source.length\r\n    this.index = 0\r\n}\r\n\r\n/**\r\n * 读取下一个字符，返回下一个字符的 code\r\n *\r\n * @return {number}\r\n */\r\nWalker.prototype.nextCode = function () {\r\n    this.index++\r\n    return this.source.charCodeAt(this.index)\r\n}\r\n\r\n/**\r\n * 向前读取字符，直到遇到指定字符再停止\r\n * 未指定字符时，当遇到第一个非空格、制表符的字符停止\r\n *\r\n * @param {number=} charCode 指定字符的code\r\n * @return {boolean} 当指定字符时，返回是否碰到指定的字符\r\n */\r\nWalker.prototype.goUntil = function (charCode) {\r\n    let code\r\n    while(this.index < this.len && (code = this.source.charCodeAt(this.index))){\r\n        switch(code){\r\n            case 32: //空格\r\n            case 9: //制表\r\n            case 13: // \\r\r\n            case 10: // \\n\r\n                this.index++\r\n                break;\r\n            default:\r\n                if(code === charCode){\r\n                    this.index++\r\n                    return 1\r\n                }\r\n                return\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * 向前读取符合规则的字符片段，并返回规则匹配结果\r\n *\r\n * @param {RegExp} reg 字符片段的正则表达式\r\n * @param {boolean} isMatchStart 是否必须匹配当前位置\r\n * @return {Array?}\r\n */\r\nWalker.prototype.match = function (reg, isMatchStart) {\r\n    reg.lastIndex = this.index\r\n\r\n    let match = reg.exec(this.source)\r\n    console.log('match', match)\r\n\r\n    if(match && (!isMatchStart || this.index === match.index)){\r\n        this.index = reg.lastIndex\r\n        return match\r\n    }\r\n}","import { readTertiaryExpr } from './read-tertiary-expr.js'\r\nimport { Walker } from './walker.js'\r\n/**\r\n * 解析表达式\r\n *\r\n * @param {string} source 源码\r\n * @return {Object}\r\n */\r\nexport function parseExpr (source) {\r\n    if(!source){\r\n        return\r\n    }\r\n\r\n    if(typeof source === 'object' && source.type){\r\n        return source\r\n    }\r\n\r\n    return readTertiaryExpr(new Walker(source));\r\n}","import { ExprType } from '../parser/expr-type.js'\r\n\r\n/**\r\n * 计算表达式的值\r\n *\r\n * @param {Object} expr 表达式对象\r\n * @param {Data} data 数据容器对象\r\n * @param {Component=} owner 所属组件环境\r\n * @return {*}\r\n */\r\nexport function evalExpr (expr, data, owner) {\r\n    if(expr.value != null){\r\n        return expr.value\r\n    }\r\n\r\n    let value\r\n\r\n    switch (expr.type) {\r\n        case ExprType.NULL:\r\n            return null\r\n        case ExprType.UNARY:\r\n            value = evalExpr(expr.expr, data, owner)\r\n            switch(expr.operator){\r\n                case 33: //如果是 ！\r\n                    value = !value\r\n                    break\r\n                case 43: //如果是 +\r\n                    value = +value\r\n                    break\r\n                case 45: //如果是 -\r\n                    value = 0 - value\r\n                    break;\r\n            }\r\n            return value\r\n            case ExprType.BINARY:\r\n                value = evalExpr(expr.segs[0], data, owner)\r\n                let rightValue = evalExpr(expr.segs[1], data, owner)\r\n                switch(expr.operator){\r\n                    \r\n                }\r\n                return value\r\n        default:\r\n            break;\r\n    }\r\n}","import { parseExpr } from '../parser/parse-Expr.js'\r\nimport { evalExpr } from './eval-expr.js'\r\n//响应式数据方法\r\n//parent为父级数据\r\n//data为初始数据\r\n//listeners为收集数据发生改变的容器\r\nfunction Data (data, parent) {\r\n    this.parent = parent\r\n    this.raw = data || {}\r\n    this.listeners = []\r\n}\r\n\r\n//该方法为获取数据\r\n/**\r\n * 获取数据项\r\n *\r\n * @param {string|Object?} expr 数据项路径\r\n * @param {Data?} callee 当前数据获取的调用环境\r\n * @return {*}\r\n */\r\nData.prototype.get = function (expr, callee) {\r\n    let value = this.raw\r\n    //判断第一个参数有没有传，没传直接返回整个数据\r\n    if(!expr){\r\n        return value\r\n    }\r\n    //不是对象我们需要对他进行处理，得到数据路径\r\n    if(typeof expr !== 'object'){\r\n        expr = parseExpr(expr)\r\n    }\r\n\r\n    let paths = expr.paths\r\n    callee = callee || this\r\n\r\n    //拿解析到的数据路径的第一个key，到原始数据中去找对应的key\r\n    value = value[paths[0].value]\r\n    if(typeof value === 'undefined' && this.parent){\r\n        value = this.parent.get(expr, callee)\r\n    }else{\r\n        for(let i = 1,l = paths.length;value !== null && i < l;i++){\r\n            value = value[paths[i].value || evalExpr(paths[i], callee)]\r\n        }\r\n    }\r\n\r\n    return value\r\n}\r\n\r\n/**\r\n * 数据对象变更操作\r\n *\r\n * @inner\r\n * @param {Object|Array} source 要变更的源数据\r\n * @param {Array} exprPaths 属性路径\r\n * @param {number} pathsStart 当前处理的属性路径指针位置\r\n * @param {number} pathsLen 属性路径长度\r\n * @param {*} value 变更属性值\r\n * @param {Data} data 对应的Data对象\r\n * @return {*} 变更后的新数据\r\n */\r\nData.prototype.immutableSet = function (source, exprPaths, pathsStart, pathsLen, value, data) {\r\n\r\n}\r\n\r\n//改变数据\r\n/**\r\n * 设置数据项\r\n *\r\n * @param {string|Object} expr 数据项路径\r\n * @param {*} value 数据值\r\n * @param {Object=} option 设置参数\r\n * @param {boolean} option.silent 静默设置，不触发变更事件\r\n */\r\nData.prototype.set = function (expr, value, option) {\r\n\r\n}\r\n\r\nexport default Data","import Data from './runtime/data.js'\r\nimport { parseExpr } from './parser/parse-Expr.js'\r\n\r\nlet san = {\r\n    version: '1.0.0',\r\n\r\n    /**\r\n         * 解析表达式\r\n         *\r\n         * @param {string} source 源码\r\n         * @return {Object}\r\n         */\r\n     parseExpr: parseExpr,\r\n\r\n    /**\r\n     * 数据类\r\n     *\r\n     * @class\r\n     * @param {Object?} data 初始数据\r\n     * @param {Data?} parent 父级数据对象\r\n     */\r\n    Data: Data\r\n}\r\nif(typeof window !== 'undefined') window.san = san\r\nexport default san"],"names":["readIdent","walker","match","Error","source","slice","index","readUnaryExpr","goUntil","currentCode","charCodeAt","expr","operator","value","type","postUnaryExpr","charCode","startCode","walkLoop","nextCode","String","fromCharCode","parseInt","readString","readTertiaryExpr","parenthesized","readParenthesizedExpr","arrItems","item","push","spread","items","objItems","walkerIndexBeforeName","name","paths","defaultArgs","args","result","firstSeg","accessorLoop","readAccessor","readCall","readMultiplicativeExpr","code","segs","readAdditiveExpr","readRelationalExpr","readLogicalANDExpr","readEqualityExpr","readLogicalORExpr","conditional","yesExpr","Walker","this","len","length","parseExpr","evalExpr","data","owner","Data","parent","raw","listeners","prototype","reg","isMatchStart","lastIndex","exec","console","log","get","callee","i","l","immutableSet","exprPaths","pathsStart","pathsLen","set","option","san","version","window"],"sourceRoot":""}